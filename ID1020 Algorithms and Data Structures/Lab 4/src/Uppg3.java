/*
* Result with database.txt and AL as start node
AL to AL (0,00)
AL to FL (0,04)  AL-FL 0,04000
AL to GA (0,38)  AL-FL 0,04000   FL-GA 0,34000
AL to MS (0,18)  AL-MS 0,18000
AL to TN (0,33)  AL-MS 0,18000   MS-TN 0,15000
AL to AR (0,28)  AL-MS 0,18000   AR-MS 0,10000
AL to LA (0,44)  AL-MS 0,18000   LA-MS 0,26000
AL to MO (0,83)  AL-MS 0,18000   AR-MS 0,10000   AR-MO 0,55000
AL to OK (0,74)  AL-MS 0,18000   AR-MS 0,10000   AR-TX 0,07000   OK-TX 0,39000
AL to TX (0,35)  AL-MS 0,18000   AR-MS 0,10000   AR-TX 0,07000
AL to AZ (1,27)  AL-MS 0,18000   AR-MS 0,10000   AR-TX 0,07000   NM-TX 0,37000   AZ-NM 0,55000
AL to CA (1,71)  AL-MS 0,18000   AR-MS 0,10000   AR-TX 0,07000   NM-TX 0,37000   AZ-NM 0,55000   AZ-CA 0,44000
AL to NM (0,72)  AL-MS 0,18000   AR-MS 0,10000   AR-TX 0,07000   NM-TX 0,37000
AL to NV (1,55)  AL-MS 0,18000   AR-MS 0,10000   AR-TX 0,07000   NM-TX 0,37000   AZ-NM 0,55000   AZ-NV 0,28000
AL to UT (1,32)  AL-MS 0,18000   AR-MS 0,10000   AR-TX 0,07000   OK-TX 0,39000   KS-OK 0,01000   CO-KS 0,21000   CO-UT 0,36000
AL to OR (1,76)  AL-MS 0,18000   AR-MS 0,10000   AR-MO 0,55000   MO-NE 0,25000   NE-WY 0,43000   ID-WY 0,24000   ID-OR 0,01000
AL to CO (0,96)  AL-MS 0,18000   AR-MS 0,10000   AR-TX 0,07000   OK-TX 0,39000   KS-OK 0,01000   CO-KS 0,21000
AL to KS (0,75)  AL-MS 0,18000   AR-MS 0,10000   AR-TX 0,07000   OK-TX 0,39000   KS-OK 0,01000
AL to NE (1,08)  AL-MS 0,18000   AR-MS 0,10000   AR-MO 0,55000   MO-NE 0,25000
AL to WY (1,51)  AL-MS 0,18000   AR-MS 0,10000   AR-MO 0,55000   MO-NE 0,25000   NE-WY 0,43000
AL to CT (0,99)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000   CT-NY 0,05000
AL to MA (1,15)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000   MA-NY 0,21000
AL to NY (0,94)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000
AL to RI (1,28)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000   MA-NY 0,21000   MA-RI 0,13000
AL to DC (1,68)  AL-MS 0,18000   MS-TN 0,15000   TN-VA 0,74000   DC-VA 0,61000
AL to MD (1,24)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000   NJ-NY 0,09000   DE-NJ 0,12000   DE-MD 0,09000
AL to VA (1,07)  AL-MS 0,18000   MS-TN 0,15000   TN-VA 0,74000
AL to DE (1,15)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000   NJ-NY 0,09000   DE-NJ 0,12000
AL to NJ (1,03)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000   NJ-NY 0,09000
AL to PA (0,85)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000
AL to NC (0,91)  AL-MS 0,18000   MS-TN 0,15000   NC-TN 0,58000
AL to SC (0,92)  AL-FL 0,04000   FL-GA 0,34000   GA-SC 0,54000
AL to IA (0,96)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   IL-KY 0,25000   IA-IL 0,09000
AL to IL (0,87)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   IL-KY 0,25000
AL to MN (1,14)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   IL-KY 0,25000   IA-IL 0,09000   IA-MN 0,18000
AL to SD (1,15)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   IL-KY 0,25000   IA-IL 0,09000   IA-MN 0,18000   MN-SD 0,01000
AL to WI (1,53)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   IL-KY 0,25000   IA-IL 0,09000   IA-MN 0,18000   MN-WI 0,39000
AL to ID (1,75)  AL-MS 0,18000   AR-MS 0,10000   AR-MO 0,55000   MO-NE 0,25000   NE-WY 0,43000   ID-WY 0,24000
AL to MT (1,26)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   IL-KY 0,25000   IA-IL 0,09000   IA-MN 0,18000   MN-SD 0,01000   MT-SD 0,11000
AL to WA (2,06)  AL-MS 0,18000   AR-MS 0,10000   AR-MO 0,55000   MO-NE 0,25000   NE-WY 0,43000   ID-WY 0,24000   ID-WA 0,31000
AL to IN (0,90)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   IL-KY 0,25000   IL-IN 0,03000
AL to KY (0,62)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000
AL to MI (1,26)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   IL-KY 0,25000   IL-IN 0,03000   IN-MI 0,36000
AL to OH (1,18)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   OH-WV 0,50000
AL to WV (0,68)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000
AL to NH (1,41)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000   MA-NY 0,21000   MA-NH 0,26000
AL to VT (1,29)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000   MA-NY 0,21000   MA-VT 0,14000
AL to ME (1,86)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   KY-WV 0,06000   PA-WV 0,17000   NY-PA 0,09000   MA-NY 0,21000   MA-NH 0,26000   ME-NH 0,45000
AL to ND (1,40)  AL-MS 0,18000   MS-TN 0,15000   KY-TN 0,29000   IL-KY 0,25000   IA-IL 0,09000   IA-MN 0,18000   MN-SD 0,01000   ND-SD 0,25000
* */

import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

/**
 *  The class represents a data type for solving
 *  the single-source shortest paths problem in edge-weighted graphs
 *  where the edge weights are nonnegative.
 *  <p>
 *  This implementation uses Dijkstra's algorithm with a binary heap.
 *  The constructor takes time proportional to <em>E</em> log <em>V</em>,
 *  where <em>V</em> is the number of vertices and <em>E</em> is the number of edges.
 *  Each call to {@code distTo(int)} and {@code hasPathTo(int)} takes constant time;
 *  each call to {@code pathTo(int)} takes time proportional to the number of
 *  edges in the shortest path returned.
 *  <p>
 *  For additional documentation,
 *  see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of
 *  <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 *  See {DijkstraSP} for a version on edge-weighted digraphs.
 *
 *  @author Robert Sedgewick
 *  @author Kevin Wayne
 *  @author Nate Liu
 */
class Uppg3 {
    private double[] distTo;          // distTo[v] = distance  of shortest s->v path
    private Edge[] edgeTo;            // edgeTo[v] = last edge on shortest s->v path
    private IndexMinPQ<Double> pq;    // priority queue of vertices

    /**
     * Computes a shortest-paths tree from the source vertex {@code s} to every
     * other vertex in the edge-weighted graph {@code G}.
     *
     * @param  G the edge-weighted digraph
     * @param  s the source vertex
     * @throws IllegalArgumentException if an edge weight is negative
     * @throws IllegalArgumentException unless {@code 0 <= s < V}
     */
    public Uppg3(EdgeWeightedGraph G, int s) {
        distTo = new double[G.V()];
        edgeTo = new Edge[G.V()];

        for (int v = 0; v < G.V(); v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = 0.0;

        // relax vertices in order of distance from s
        pq = new IndexMinPQ<>(G.V());
        pq.insert(s, distTo[s]);
        while (!pq.isEmpty()) {
            int v = pq.delMin();
            for (Edge e : G.adj(v))
                relax(e, v);
        }
    }

    // relax edge e and update pq if changed
    private void relax(Edge e, int v) {
        int w = e.other(v);
        if (distTo[w] > distTo[v] + e.weight()) {
            distTo[w] = distTo[v] + e.weight();
            edgeTo[w] = e;
            if (pq.contains(w)) pq.decreaseKey(w, distTo[w]);
            else                pq.insert(w, distTo[w]);
        }
    }

    /**
     * Returns the length of a shortest path between the source vertex {@code s} and
     * vertex {@code v}.
     *
     * @param  v the destination vertex
     * @return the length of a shortest path between the source vertex {@code s} and
     *         the vertex {@code v}; {@code Double.POSITIVE_INFINITY} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public double distTo(int v) {
        return distTo[v];
    }

    /**
     * Returns true if there is a path between the source vertex {@code s} and
     * vertex {@code v}.
     *
     * @param  v the destination vertex
     * @return {@code true} if there is a path between the source vertex
     *         {@code s} to vertex {@code v}; {@code false} otherwise
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public boolean hasPathTo(int v) {
        return distTo[v] < Double.POSITIVE_INFINITY;
    }

    /**
     * Returns a shortest path between the source vertex {@code s} and vertex {@code v}.
     *
     * @param  v the destination vertex
     * @return a shortest path between the source vertex {@code s} and vertex {@code v};
     *         {@code null} if no such path
     * @throws IllegalArgumentException unless {@code 0 <= v < V}
     */
    public Iterable<Edge> pathTo(int v) {
        if (!hasPathTo(v)) return null;
        Stack<Edge> path = new Stack<>();
        int x = v;
        for (Edge e = edgeTo[v]; e != null; e = edgeTo[x]) {
            path.push(e);
            x = e.other(x);
        }
        return path;
    }

    /**
     * Unit tests the {@code Uppg3} data type.
     *
     * @param args the command-line arguments
     */
    public static void main(String[] args) throws FileNotFoundException {
        // Takes the file specified as input
        File file = new File(args[0]);
        Scanner in = new Scanner(file);

        Stack<String> stack = new Stack<>();
        int V = 0;
        while (in.hasNext()) {
            String key = in.next();
            if (!stack.contains(key)) {
                stack.push(key);
                V++;
            }
        }

        in = new Scanner(file);
        EdgeWeightedGraph G = new EdgeWeightedGraph(V, in);
        int s = Integer.parseInt(args[1]);

        // compute shortest paths
        Uppg3 sp = new Uppg3(G, s);
        // print shortest path
        for (int t = 0; t < G.V(); t++) {
            if (sp.hasPathTo(t)) {
                System.out.printf("%s to %s (%.2f)  ", G.getConversion(s), G.getConversion(t), sp.distTo(t));
                for (Edge e : sp.pathTo(t)) {
                    System.out.printf("%s-%s %.2f   ", G.getConversion(e.either()),
                            G.getConversion(e.other(e.either())),
                            e.weight());
                }
                System.out.println();
            }
            else {
                System.out.printf("%s to %s         no path\n", G.getConversion(s), G.getConversion(t));
            }
        }
    }

}